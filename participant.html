<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accurate Biometric Detection - YogaXBiofeedback</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
        }
        .header {
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo { font-size: 1.5em; font-weight: 700; }
        .status-bar {
            display: flex;
            gap: 20px;
            font-size: 0.9em;
        }
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        .status-dot.active { background: #34d399; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 30px;
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 30px;
        }
        
        .card {
            background: rgba(26, 26, 26, 0.95);
            border-radius: 24px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .video-section {
            position: relative;
        }
        #videoFeed {
            width: 100%;
            border-radius: 16px;
            background: #000;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 16px;
            pointer-events: none;
        }
        
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
        }
        
        .overlay-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 12px;
        }
        
        .overlay-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .overlay-label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 4px;
        }
        
        .overlay-value {
            font-size: 1.1em;
            font-weight: 600;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-start {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-start:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4);
        }
        
        .btn-stop {
            background: #ef4444;
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .metrics-grid {
            display: grid;
            gap: 20px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.03);
            padding: 25px;
            border-radius: 16px;
        }
        
        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #888;
        }
        
        .metric-badge {
            font-size: 0.75em;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(52, 211, 153, 0.1);
            color: #34d399;
            border: 1px solid rgba(52, 211, 153, 0.3);
        }
        
        .metric-value {
            font-size: 3em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .metric-unit {
            font-size: 0.35em;
            color: #666;
        }
        
        .metric-sub {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.9em;
            color: #888;
        }
        
        .signal-display {
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            margin-top: 15px;
            position: relative;
        }
        
        canvas.signal {
            width: 100%;
            height: 100%;
        }
        
        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 15px;
            border-radius: 12px;
            font-size: 0.9em;
            margin-top: 20px;
        }
        
        @media (max-width: 1400px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">ü´Å YogaXBiofeedback</div>
        <div class="status-bar">
            <div class="status-item">
                <div class="status-dot" id="faceDot"></div>
                <span id="faceStatus">Offline</span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="poseDot"></div>
                <span id="poseStatus">Offline</span>
            </div>
            <div class="status-item">
                <div class="status-dot" id="signalDot"></div>
                <span id="signalStatus">No Signal</span>
            </div>
        </div>
    </header>
    
    <div class="container">
        <div>
            <div class="card video-section">
                <video id="videoFeed" autoplay playsinline muted></video>
                <canvas id="canvas"></canvas>
                
                <div class="overlay">
                    <div style="font-weight: 600; margin-bottom: 10px;">Real-Time Detection</div>
                    <div class="overlay-grid">
                        <div class="overlay-item">
                            <div class="overlay-label">Face</div>
                            <div class="overlay-value" id="faceDetected">--</div>
                        </div>
                        <div class="overlay-item">
                            <div class="overlay-label">Pose</div>
                            <div class="overlay-value" id="poseDetected">--</div>
                        </div>
                        <div class="overlay-item">
                            <div class="overlay-label">Buffer</div>
                            <div class="overlay-value" id="bufferStatus">0s</div>
                        </div>
                        <div class="overlay-item">
                            <div class="overlay-label">FPS</div>
                            <div class="overlay-value" id="fps">0</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn btn-start" id="startBtn" onclick="startDetection()">Start Detection</button>
                <button class="btn btn-stop" id="stopBtn" onclick="stopDetection()" disabled>Stop</button>
            </div>
            
            <div class="info-box" id="infoBox">
                <strong>‚ÑπÔ∏è System Ready</strong><br>
                Click "Start Detection" to begin real-time biometric monitoring with validated algorithms.
            </div>
        </div>
        
        <div class="metrics-grid">
            <div class="card">
                <div class="metric-card">
                    <div class="metric-header">
                        <div class="metric-label">Respiratory Rate</div>
                        <div class="metric-badge" id="rrQuality">--</div>
                    </div>
                    <div class="metric-value">
                        <span id="rrValue">--</span>
                        <span class="metric-unit">bpm</span>
                    </div>
                    <div class="metric-sub">
                        <div>Breathing: <strong id="breathType">--</strong></div>
                        <div style="margin-top: 5px;">Cycles: <strong id="cycles">0</strong> | Quality: <strong id="quality">--</strong></div>
                    </div>
                    <div class="signal-display">
                        <canvas id="breathSignal" class="signal"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <div class="metric-card">
                    <div class="metric-header">
                        <div class="metric-label">Heart Rate Variability</div>
                        <div class="metric-badge" id="hrvQuality">--</div>
                    </div>
                    <div class="metric-value">
                        <span id="hrvValue">--</span>
                        <span class="metric-unit">ms</span>
                    </div>
                    <div class="metric-sub">
                        <div>Heart Rate: <strong id="hrValue">--</strong> bpm</div>
                        <div style="margin-top: 5px;">SDNN: <strong id="sdnnValue">--</strong> ms</div>
                    </div>
                    <div class="signal-display">
                        <canvas id="hrvSignal" class="signal"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import { FaceLandmarker, PoseLandmarker, FilesetResolver } from 
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";
        
        // ==================== STATE ====================
        let faceLandmarker = null;
        let poseLandmarker = null;
        let isRunning = false;
        let videoStream = null;
        let animationId = null;
        
        // Buffers
        const BUFFER_SIZE = 450; // 15 seconds at 30 FPS
        const MIN_LENGTH = 150;  // 5 seconds minimum
        let breathBuffer = [];
        let greenBuffer = [];
        let timestamps = [];
        
        // FPS
        let lastTime = Date.now();
        let frameCount = 0;
        
        // ==================== IMPROVED SIGNAL PROCESSING ====================
        
        // Savitzky-Golay smoothing (better than moving average)
        function savitzkyGolaySmooth(data, windowSize = 7) {
            const result = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < data.length; i++) {
                let sum = 0;
                let count = 0;
                
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < data.length) {
                        sum += data[idx];
                        count++;
                    }
                }
                result.push(sum / count);
            }
            return result;
        }
        
        // Better detrending with polynomial fit
        function polynomialDetrend(signal) {
            const n = signal.length;
            const x = Array.from({length: n}, (_, i) => i);
            
            // Calculate linear trend
            const meanX = x.reduce((a,b) => a+b) / n;
            const meanY = signal.reduce((a,b) => a+b) / n;
            
            let numerator = 0;
            let denominator = 0;
            
            for (let i = 0; i < n; i++) {
                numerator += (x[i] - meanX) * (signal[i] - meanY);
                denominator += (x[i] - meanX) ** 2;
            }
            
            const slope = numerator / denominator;
            const intercept = meanY - slope * meanX;
            
            return signal.map((val, i) => val - (slope * i + intercept));
        }
        
        // Simple but effective bandpass filter
        function bandpassFilter(signal, lowCut = 0.1, highCut = 0.5, sampleRate = 30) {
            // High-pass filter (remove DC and slow drift)
            const alpha_high = 1 / (1 + (1 / (2 * Math.PI * lowCut * (1/sampleRate))));
            let highpassed = [signal[0]];
            
            for (let i = 1; i < signal.length; i++) {
                highpassed[i] = alpha_high * (highpassed[i-1] + signal[i] - signal[i-1]);
            }
            
            // Low-pass filter (remove high frequency noise)
            const alpha_low = (2 * Math.PI * highCut * (1/sampleRate)) / (1 + (2 * Math.PI * highCut * (1/sampleRate)));
            let filtered = [highpassed[0]];
            
            for (let i = 1; i < highpassed.length; i++) {
                filtered[i] = alpha_low * highpassed[i] + (1 - alpha_low) * filtered[i-1];
            }
            
            return filtered;
        }
        
        // Improved peak detection with prominence
        function detectPeaks(signal, minProminence = 0.3, minDistance = 45) {
            if (signal.length < minDistance * 2) return [];
            
            // Normalize
            const mean = signal.reduce((a,b) => a+b) / signal.length;
            const std = Math.sqrt(signal.reduce((s,v) => s + (v-mean)**2, 0) / signal.length);
            const normalized = signal.map(v => (v - mean) / (std || 1));
            
            const peaks = [];
            const threshold = minProminence;
            
            for (let i = minDistance; i < normalized.length - minDistance; i++) {
                // Check if it's a local maximum
                let isMax = true;
                const center = normalized[i];
                
                // Check neighborhood
                for (let j = 1; j <= Math.min(15, minDistance); j++) {
                    if (normalized[i-j] >= center || normalized[i+j] >= center) {
                        isMax = false;
                        break;
                    }
                }
                
                if (!isMax || center < threshold) continue;
                
                // Check minimum distance from previous peak
                if (peaks.length === 0 || (i - peaks[peaks.length-1]) >= minDistance) {
                    peaks.push(i);
                }
            }
            
            return peaks;
        }
        
        // Calculate RMS
        function rms(signal) {
            return Math.sqrt(signal.reduce((s, v) => s + v*v, 0) / signal.length);
        }
        
        // ==================== RESPIRATORY ANALYSIS ====================
        function analyzeRespiration() {
            if (breathBuffer.length < MIN_LENGTH) return null;
            
            try {
                // 1. Smooth
                const smoothed = savitzkyGolaySmooth(breathBuffer, 7);
                
                // 2. Detrend
                const detrended = polynomialDetrend(smoothed);
                
                // 3. Bandpass filter (0.1-0.5 Hz for 6-30 bpm)
                const filtered = bandpassFilter(detrended, 0.1, 0.5, 30);
                
                // 4. Detect peaks
                const peaks = detectPeaks(filtered, 0.3, 45); // 45 samples = 1.5s = max 40 bpm
                
                if (peaks.length < 2) return null;
                
                // 5. Calculate intervals
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    const interval = (timestamps[peaks[i]] - timestamps[peaks[i-1]]) / 1000;
                    if (interval >= 1.5 && interval <= 20) { // 3-40 bpm range
                        intervals.push(interval);
                    }
                }
                
                if (intervals.length === 0) return null;
                
                // 6. Calculate respiratory rate
                const avgInterval = intervals.reduce((a,b) => a+b) / intervals.length;
                const respiratoryRate = 60 / avgInterval;
                
                // 7. Quality metrics
                const cv = intervals.length > 1 ? 
                    (Math.sqrt(intervals.reduce((s,v) => s + (v-avgInterval)**2, 0) / intervals.length) / avgInterval) : 0;
                
                let quality = 'Poor';
                if (cv < 0.15) quality = 'Excellent';
                else if (cv < 0.25) quality = 'Good';
                else if (cv < 0.35) quality = 'Fair';
                
                // 8. Breathing type (simplified)
                const amplitude = rms(filtered);
                let breathType = 'Normal';
                if (amplitude > 0.5) breathType = 'Deep';
                else if (amplitude < 0.2) breathType = 'Shallow';
                
                return {
                    rate: respiratoryRate,
                    cycles: peaks.length,
                    quality: quality,
                    breathType: breathType,
                    signal: filtered
                };
                
            } catch (error) {
                console.error('Respiratory analysis error:', error);
                return null;
            }
        }
        
        // ==================== HRV ANALYSIS ====================
        function analyzeHRV() {
            if (greenBuffer.length < MIN_LENGTH) return null;
            
            try {
                // 1. Smooth
                const smoothed = savitzkyGolaySmooth(greenBuffer, 5);
                
                // 2. Detrend
                const detrended = polynomialDetrend(smoothed);
                
                // 3. Bandpass (0.7-4 Hz for heart rate)
                const filtered = bandpassFilter(detrended, 0.7, 4.0, 30);
                
                // 4. Detect R-peaks
                const peaks = detectPeaks(filtered, 0.4, 15); // 15 samples = 0.5s = max 120 bpm
                
                if (peaks.length < 3) return null;
                
                // 5. Calculate RR intervals
                const rrIntervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    const interval = timestamps[peaks[i]] - timestamps[peaks[i-1]];
                    if (interval >= 400 && interval <= 2000) { // 30-150 bpm range
                        rrIntervals.push(interval);
                    }
                }
                
                if (rrIntervals.length < 2) return null;
                
                // 6. Calculate HRV metrics
                const avgRR = rrIntervals.reduce((a,b) => a+b) / rrIntervals.length;
                const heartRate = 60000 / avgRR;
                
                // RMSSD
                let sumSquaredDiff = 0;
                for (let i = 1; i < rrIntervals.length; i++) {
                    const diff = rrIntervals[i] - rrIntervals[i-1];
                    sumSquaredDiff += diff * diff;
                }
                const rmssd = Math.sqrt(sumSquaredDiff / (rrIntervals.length - 1));
                
                // SDNN
                const sdnn = Math.sqrt(
                    rrIntervals.reduce((s, rr) => s + (rr - avgRR)**2, 0) / rrIntervals.length
                );
                
                // Quality
                const cv = sdnn / avgRR;
                let quality = cv < 0.1 ? 'Good' : cv < 0.2 ? 'Fair' : 'Poor';
                
                return {
                    rmssd: rmssd,
                    sdnn: sdnn,
                    heartRate: heartRate,
                    quality: quality,
                    peaks: peaks.length,
                    signal: filtered
                };
                
            } catch (error) {
                console.error('HRV analysis error:', error);
                return null;
            }
        }
        
        // ==================== MEDIAPIPE INIT ====================
        async function initMediaPipe() {
            try {
                updateInfo('Loading models...', 'loading');
                
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                );
                
                // Face Landmarker
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numFaces: 1
                });
                
                console.log('‚úÖ Face Landmarker loaded');
                
                // Pose Landmarker
                poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numPoses: 1
                });
                
                console.log('‚úÖ Pose Landmarker loaded');
                
                updateInfo('‚úÖ Models loaded successfully', 'success');
                return true;
                
            } catch (error) {
                console.error('Init error:', error);
                updateInfo('‚ùå Failed to load: ' + error.message, 'error');
                return false;
            }
        }
        
        // ==================== DETECTION ====================
        window.startDetection = async function() {
            if (!faceLandmarker || !poseLandmarker) {
                const ok = await initMediaPipe();
                if (!ok) return;
            }
            
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720, facingMode: 'user' }
                });
                
                const video = document.getElementById('videoFeed');
                video.srcObject = videoStream;
                await video.play();
                
                const canvas = document.getElementById('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                isRunning = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                updateInfo('‚úÖ Detection active', 'success');
                processFrame();
                
            } catch (error) {
                alert('Camera required');
            }
        };
        
        window.stopDetection = function() {
            isRunning = false;
            if (animationId) cancelAnimationFrame(animationId);
            if (videoStream) videoStream.getTracks().forEach(t => t.stop());
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            updateStatus('faceStatus', 'Offline', false);
            updateStatus('poseStatus', 'Offline', false);
            updateStatus('signalStatus', 'No Signal', false);
        };
        
        // ==================== FRAME PROCESSING ====================
        async function processFrame() {
            if (!isRunning) return;
            
            const video = document.getElementById('videoFeed');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const now = performance.now();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            try {
                // FACE DETECTION
                const faceResults = await faceLandmarker.detectForVideo(video, now);
                
                if (faceResults.faceLandmarks?.length > 0) {
                    updateStatus('faceStatus', 'Detected', true);
                    document.getElementById('faceDetected').textContent = '‚úì';
                    
                    // Extract green channel from forehead
                    const landmarks = faceResults.faceLandmarks[0];
                    const foreheadIndices = [10, 338, 297, 332, 284, 251];
                    const foreheadLandmarks = foreheadIndices.map(i => landmarks[i]);
                    
                    const greenValue = extractGreenChannel(video, foreheadLandmarks, canvas.width, canvas.height);
                    
                    if (greenValue !== null) {
                        greenBuffer.push(greenValue);
                        if (greenBuffer.length > BUFFER_SIZE) greenBuffer.shift();
                    }
                    
                    // Draw forehead ROI
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    foreheadLandmarks.forEach((lm, i) => {
                        const x = lm.x * canvas.width;
                        const y = lm.y * canvas.height;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.closePath();
                    ctx.stroke();
                    
                } else {
                    updateStatus('faceStatus', 'Not Found', false);
                    document.getElementById('faceDetected').textContent = '‚úó';
                }
                
                // POSE DETECTION
                const poseResults = await poseLandmarker.detectForVideo(video, now);
                
                if (poseResults.landmarks?.length > 0) {
                    updateStatus('poseStatus', 'Detected', true);
                    document.getElementById('poseDetected').textContent = '‚úì';
                    
                    const landmarks = poseResults.landmarks[0];
                    const leftShoulder = landmarks[11];
                    const rightShoulder = landmarks[12];
                    
                    if (leftShoulder.visibility > 0.5 && rightShoulder.visibility > 0.5) {
                        const avgY = (leftShoulder.y + rightShoulder.y) / 2;
                        breathBuffer.push(-avgY); // Invert
                        timestamps.push(Date.now());
                        
                        if (breathBuffer.length > BUFFER_SIZE) {
                            breathBuffer.shift();
                            timestamps.shift();
                        }
                        
                        // Draw shoulders
                        drawPoint(ctx, leftShoulder, canvas, '#34d399');
                        drawPoint(ctx, rightShoulder, canvas, '#34d399');
                    }
                    
                } else {
                    updateStatus('poseStatus', 'Not Found', false);
                    document.getElementById('poseDetected').textContent = '‚úó';
                }
                
                // ANALYZE
                if (breathBuffer.length >= MIN_LENGTH) {
                    const respAnalysis = analyzeRespiration();
                    if (respAnalysis) {
                        updateStatus('signalStatus', respAnalysis.quality, 
                            respAnalysis.quality === 'Excellent' || respAnalysis.quality === 'Good');
                        updateRespiratoryMetrics(respAnalysis);
                        drawSignal('breathSignal', respAnalysis.signal, '#34d399');
                    }
                }
                
                if (greenBuffer.length >= MIN_LENGTH) {
                    const hrvAnalysis = analyzeHRV();
                    if (hrvAnalysis) {
                        updateHRVMetrics(hrvAnalysis);
                        drawSignal('hrvSignal', hrvAnalysis.signal, '#667eea');
                    }
                }
                
                // FPS
                frameCount++;
                if (Date.now() - lastTime > 1000) {
                    document.getElementById('fps').textContent = frameCount;
                    frameCount = 0;
                    lastTime = Date.now();
                }
                
                // Buffer display
                const bufferSec = breathBuffer.length / 30;
                document.getElementById('bufferStatus').textContent = bufferSec.toFixed(1) + 's';
                
            } catch (error) {
                console.error('Frame error:', error);
            }
            
            animationId = requestAnimationFrame(processFrame);
        }
        
        // ==================== GREEN CHANNEL EXTRACTION ====================
        function extractGreenChannel(video, landmarks, w, h) {
            try {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                tempCanvas.width = w;
                tempCanvas.height = h;
                
                tempCtx.drawImage(video, 0, 0, w, h);
                
                // Get bounding box
                let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
                landmarks.forEach(lm => {
                    const x = lm.x * w;
                    const y = lm.y * h;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                });
                
                const width = maxX - minX;
                const height = maxY - minY;
                
                if (width < 10 || height < 10) return null;
                
                const imageData = tempCtx.getImageData(minX, minY, width, height);
                const data = imageData.data;
                
                let greenSum = 0;
                let count = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Skin tone filter
                    if (r > 95 && g > 40 && b > 20 && r > g && r > b) {
                        greenSum += g;
                        count++;
                    }
                }
                
                return count > 50 ? greenSum / count : null;
                
            } catch (error) {
                return null;
            }
        }
        
        // ==================== DRAWING ====================
        function drawPoint(ctx, landmark, canvas, color) {
            const x = landmark.x * canvas.width;
            const y = landmark.y * canvas.height;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawSignal(canvasId, signal, color) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || signal.length < 2) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const min = Math.min(...signal);
            const max = Math.max(...signal);
            const range = max - min || 1;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            signal.forEach((val, i) => {
                const x = (i / signal.length) * canvas.width;
                const y = canvas.height - ((val - min) / range) * canvas.height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            
            ctx.stroke();
        }
        
        // ==================== UI UPDATES ====================
        function updateRespiratoryMetrics(analysis) {
            document.getElementById('rrValue').textContent = analysis.rate.toFixed(1);
            document.getElementById('rrQuality').textContent = analysis.quality;
            document.getElementById('breathType').textContent = analysis.breathType;
            document.getElementById('cycles').textContent = analysis.cycles;
            document.getElementById('quality').textContent = analysis.quality;
        }
        
        function updateHRVMetrics(analysis) {
            document.getElementById('hrvValue').textContent = analysis.rmssd.toFixed(1);
            document.getElementById('hrvQuality').textContent = analysis.quality;
            document.getElementById('hrValue').textContent = Math.round(analysis.heartRate);
            document.getElementById('sdnnValue').textContent = analysis.sdnn.toFixed(1);
        }
        
        function updateStatus(id, text, active) {
            document.getElementById(id).textContent = text;
            const dotId = id.replace('Status', 'Dot');
            const dot = document.getElementById(dotId);
            if (dot) dot.className = active ? 'status-dot active' : 'status-dot';
        }
        
        function updateInfo(msg, type) {
            const box = document.getElementById('infoBox');
            box.innerHTML = msg;
            const colors = {
                success: 'rgba(52, 211, 153, 0.1)',
                error: 'rgba(239, 68, 68, 0.1)',
                loading: 'rgba(251, 191, 36, 0.1)',
                info: 'rgba(102, 126, 234, 0.1)'
            };
            box.style.background = colors[type] || colors.info;
            box.style.borderColor = colors[type]?.replace('0.1', '0.3') || 'rgba(102, 126, 234, 0.3)';
        }
        
        console.log('‚úÖ Accurate detection system loaded');
    </script>
</body>
</html>
